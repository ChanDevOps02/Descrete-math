//온라인 채점 사이트에 제출한 코드에서 주석을 추가한 코드입니다! 온라인에 제출한 코드와 fundemental한 내용은 동일합니다!! <23101150_강민찬>
//깃허브에서 직접 좌측 실행버튼을 눌러 컴파일 후 테스트케이스들을 입력하여 태스트해볼수도 있습니다!
//2004번은 온라인 채점사이트의 판정 알고리즘이 좀 이상한거 같습니다. 모든 테스트 케이스에 대해 올바른 출력값을 만들어냄에도 불구하고 계속 틀리다고 나옵니다. 
package Week4;

import java.util.Scanner;

public class Practice2_2004 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // ------------------------------------------------------------------
        // 1. 행렬 A와 행렬 B의 크기와 값을 입력받는 부분
        // ------------------------------------------------------------------
        // 첫 번째 줄에 행렬 A의 행의 수(N), A의 열의 수(M), 행렬 B의 행의 수(I), B의 열의 수(J)가 주어진다고 가정합니다.
        int N = sc.nextInt(); // 행렬 A의 행 개수
        int M = sc.nextInt(); // 행렬 A의 열 개수
        int I = sc.nextInt(); // 행렬 B의 행 개수
        int J = sc.nextInt(); // 행렬 B의 열 개수
        sc.nextLine(); // nextInt() 호출 후 남아있는 개행문자 제거

        // ------------------------------------------------------------------
        // 행렬 A의 값을 입력받기 (N행 M열)
        // ------------------------------------------------------------------
        // 2차원 배열 A를 생성하고, 각 행과 열에 해당하는 값을 차례대로 입력받습니다.
        int[][] A = new int[N][M];
        for (int r = 0; r < N; r++) { // 0부터 N-1까지 행을 반복
            for (int c = 0; c < M; c++) { // 각 행에서 0부터 M-1까지 열을 반복
                A[r][c] = sc.nextInt(); // Scanner를 통해 정수를 읽어서 배열 A의 해당 위치에 저장
            }
        }
        sc.nextLine(); // 행렬 A 입력 후 남은 개행문자 제거

        // ------------------------------------------------------------------
        // 행렬 B의 값을 입력받기 (I행 J열)
        // ------------------------------------------------------------------
        int[][] B = new int[I][J];
        for (int r = 0; r < I; r++) { // 행렬 B의 각 행을 반복
            for (int c = 0; c < J; c++) { // 각 행에서 열을 반복
                B[r][c] = sc.nextInt(); // 배열 B의 해당 위치에 값을 저장
            }
        }
        sc.nextLine(); // 행렬 B 입력 후 남은 개행문자 제거

        // ------------------------------------------------------------------
        // 2. 행렬 덧셈 (A + B)
        // ------------------------------------------------------------------
        // 행렬 덧셈은 두 행렬의 크기가 같을 때만 가능하므로,
        // A와 B의 행과 열의 개수가 같을 때에만 덧셈을 수행합니다.
        if (N == I && M == J) {
            // 결과를 저장할 행렬 sum을 생성 (크기는 A와 동일)
            int[][] sum = new int[N][M];
            // 각 행과 열을 순회하며 두 행렬의 해당 원소를 더함
            for (int r = 0; r < N; r++) {
                for (int c = 0; c < M; c++) {
                    sum[r][c] = A[r][c] + B[r][c]; // A와 B의 같은 위치의 원소 덧셈
                }
            }
            printMatrix(sum);      // 덧셈 결과 행렬을 출력
            System.out.println();  // 다음 연산 전 빈 줄 출력
        } else {
            // 행렬의 크기가 다르면 덧셈을 할 수 없으므로 "n" 출력
            System.out.println("n");
            System.out.println();
        }

        // ------------------------------------------------------------------
        // 3. 행렬 뺄셈 (A - B)
        // ------------------------------------------------------------------
        // 뺄셈 역시 두 행렬의 크기가 동일해야 수행 가능
        if (N == I && M == J) {
            // 결과를 저장할 행렬 diff 생성 (크기는 A와 동일)
            int[][] diff = new int[N][M];
            // 각 행과 열에 대해 뺄셈 수행
            for (int r = 0; r < N; r++) {
                for (int c = 0; c < M; c++) {
                    diff[r][c] = A[r][c] - B[r][c]; // A의 원소에서 B의 원소를 뺌
                }
            }
            printMatrix(diff);     // 뺄셈 결과 행렬 출력
            System.out.println();  // 빈 줄 출력
        } else {
            // 크기가 다르면 뺄셈 불가능하므로 "n" 출력
            System.out.println("n");
            System.out.println();
        }

        // ------------------------------------------------------------------
        // 4. 행렬 곱셈 (A × B)
        // ------------------------------------------------------------------
        // 행렬 곱셈은 A의 열 수(M)와 B의 행 수(I)가 같아야 수행 가능
        if (M == I) {
            // 결과 행렬의 크기는 A의 행 수와 B의 열 수, 즉 N×J입니다.
            int[][] prod = new int[N][J];
            // 각 결과 행렬의 원소를 계산하기 위한 반복문
            for (int r = 0; r < N; r++) { // 결과 행렬의 각 행
                for (int c = 0; c < J; c++) { // 결과 행렬의 각 열
                    int s = 0; // 누적 합을 저장할 변수 s를 0으로 초기화
                    // A의 한 행과 B의 한 열에 있는 원소들끼리 곱한 값을 모두 더함
                    for (int k = 0; k < M; k++) {
                        s += A[r][k] * B[k][c];
                    }
                    prod[r][c] = s; // 누적 합 s를 결과 행렬의 해당 위치에 저장
                }
            }
            printMatrix(prod);     // 곱셈 결과 행렬 출력
            System.out.println();  // 빈 줄 출력
        } else {
            // 행렬 곱셈이 불가능한 경우 "n" 출력
            System.out.println("n");
            System.out.println();
        }

        // ------------------------------------------------------------------
        // 5. 행렬 A의 행렬식(Determinant) 계산 및 출력
        // ------------------------------------------------------------------
        // 행렬식은 정사각 행렬(행과 열의 개수가 같은 경우)에서만 계산 가능
        if (N == M) {
            int detA = determinant(A); // 행렬 A의 행렬식을 계산
            System.out.println(detA);  // 계산된 행렬식을 출력
            System.out.println();      // 빈 줄 출력
        } else {
            // A가 정사각 행렬이 아니면 "n" 출력
            System.out.println("n");
            System.out.println();
        }

        // ------------------------------------------------------------------
        // 6. 행렬 B의 행렬식(Determinant) 계산 및 출력
        // ------------------------------------------------------------------
        if (I == J) { // 행렬 B가 정사각 행렬인 경우
            int detB = determinant(B); // 행렬 B의 행렬식 계산
            System.out.println(detB);  // 계산된 행렬식 출력
        } else {
            // 정사각 행렬이 아니면 "n" 출력
            System.out.println("n");
        }
        
        sc.close();
    }

    // ------------------------------------------------------------------
    // printMatrix 메서드: 2차원 배열(행렬)을 출력하는 역할
    // 각 행의 원소는 공백으로 구분되어 출력되며, 각 행이 출력된 후 줄바꿈됩니다.
    // ------------------------------------------------------------------
    static void printMatrix(int[][] matrix) {
        // 행렬의 각 행을 순회합니다.
        for (int r = 0; r < matrix.length; r++) {
            // 현재 행의 각 열을 순회합니다.
            for (int c = 0; c < matrix[r].length; c++) {
                System.out.print(matrix[r][c]); // 현재 원소를 출력
                // 현재 열이 행의 마지막 원소가 아니라면, 원소 사이에 공백을 출력합니다.
                if (c < matrix[r].length - 1) {
                    System.out.print(" ");
                }
            }
            // 한 행의 모든 원소를 출력한 후 줄바꿈을 수행합니다.
            System.out.println();
        }
    }

    // ------------------------------------------------------------------
    // determinant 메서드: 정사각 행렬(1×1, 2×2, 3×3)의 행렬식을 계산하는 역할
    // ------------------------------------------------------------------
    static int determinant(int[][] mat) {
        int n = mat.length; // 행렬의 행 수를 저장 (정사각 행렬이면 행 수와 열 수가 동일)
        // 정사각 행렬이 아닐 경우 계산할 수 없으므로 0을 반환
        if (n != mat[0].length) {
            return 0;
        }
        // 1×1 행렬의 경우: 행렬식은 유일한 원소의 값
        if (n == 1) {
            return mat[0][0];
        }
        // 2×2 행렬의 경우: 행렬식 = ad - bc
        else if (n == 2) {
            return mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0];
        }
        // 3×3 행렬의 경우: Sarrus 법칙을 이용하여 계산
        else if (n == 3) {
            // a, b, c는 각각 세 개의 곱셈 결과를 저장합니다.
            int a = mat[0][0] * (mat[1][1] * mat[2][2] - mat[1][2] * mat[2][1]);
            int b = mat[0][1] * (mat[1][0] * mat[2][2] - mat[1][2] * mat[2][0]);
            int c = mat[0][2] * (mat[1][0] * mat[2][1] - mat[1][1] * mat[2][0]);
            // 최종 행렬식은 a - b + c 로 계산됩니다.
            return a - b + c;
        } else {
            // 문제에서 다루지 않는 크기의 행렬은 없다고 가정하므로 0을 반환합니다.
            return 0;
        }
    }
}
